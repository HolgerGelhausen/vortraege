<!DOCTYPE html>
<!-- Version: 4.2.0 -->
<!-- Changelog:
  v4.2.0 (18.02.2026) - Logo: 72px in 84px Nav, kein Ueberlappen
  v4.1.0 (18.02.2026) - Logo: cropped-Version, 3x groesser (108px), Nav-Hoehe angepasst
  v4.0.0 (18.02.2026) - Komplett-Redesign: sema-claude Layout mit Fixed Nav, Sidebar TOC, Scroll-Spy, Mobile Toggle
  v3.0.0 (18.02.2026) - Logo oben rechts absolut, HD-Logo, Schrift deutlich groesser
  v2.0.0 (18.02.2026) - Redesign: AIPA Branding, Hero/Abstract, Montserrat, Light Theme
  v1.0.0 (18.02.2026) - Initial: obs-f Guide als HTML mit Mermaid + Prism.js
-->
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>obs-f - Obsidian Vault Analyse mit Fabric Pattern-Auswahl</title>

    <!-- OG Tags -->
    <meta property="og:title" content="obs-f - Obsidian Vault Analyse mit Fabric Pattern-Auswahl">
    <meta property="og:description" content="8 Shell-Funktionen, 28 Fabric Patterns, FZF-Menues, Claude Code Handoff. Komplette technische Anleitung zum Nachbauen.">
    <meta property="og:image" content="https://raw.githubusercontent.com/HolgerGelhausen/ai-performance-academy-assets/main/logo.png">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://holgergelhausen.github.io/vortraege/obs-f-fabric-pattern-auswahl/">
    <meta name="twitter:card" content="summary_large_image">

    <!-- Google Fonts: Montserrat -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Prism.js for code highlighting -->
    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css" rel="stylesheet">

    <style>
        /* ── CSS Custom Properties: AIPA Brand ── */
        :root {
            --aipa-schwarz: #000000;
            --aipa-weiss: #FFFFFF;
            --aipa-dunkelgrau: #1F1F1F;
            --aipa-hellgrau: #F7F8FA;
            --aipa-rot: #FF1A1A;
            --aipa-hover-rot: #E01515;
            --aipa-sekundaer: #767D8C;
            --aipa-sekundaer-hell: #D9DDE3;
            --aipa-blau-neutral: #34435C;
        }

        /* ── Reset ── */
        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
            scroll-padding-top: 80px;
        }

        body {
            font-family: 'Montserrat', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--aipa-weiss);
            color: var(--aipa-dunkelgrau);
            min-height: 100vh;
            line-height: 1.8;
            font-weight: 500;
            font-size: 16px;
        }

        /* ── Fixed Top Navigation ── */
        .top-nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: var(--aipa-weiss);
            border-bottom: 1px solid var(--aipa-sekundaer-hell);
            box-shadow: 0 1px 8px rgba(0,0,0,0.06);
            height: 64px;
        }

        .top-nav-inner {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 100%;
        }

        .top-nav-logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            text-decoration: none;
        }

        .top-nav-logo img {
            height: 36px;
            width: auto;
        }

        .top-nav-logo span {
            font-weight: 700;
            font-size: 1rem;
            color: var(--aipa-schwarz);
        }

        .top-nav-back {
            color: var(--aipa-rot);
            text-decoration: none;
            font-weight: 600;
            font-size: 0.9rem;
            transition: color 0.2s;
        }

        .top-nav-back:hover {
            color: var(--aipa-hover-rot);
        }

        /* ── Hero Section ── */
        .hero {
            margin-top: 64px;
            background: linear-gradient(180deg, var(--aipa-weiss) 0%, var(--aipa-hellgrau) 100%);
            padding: 4rem 1.5rem 3rem;
            text-align: center;
            border-bottom: 1px solid var(--aipa-sekundaer-hell);
        }

        .hero-inner {
            max-width: 860px;
            margin: 0 auto;
        }

        .hero h1 {
            font-size: 2.4rem;
            font-weight: 700;
            color: var(--aipa-schwarz);
            line-height: 1.2;
            margin-bottom: 1rem;
        }

        .hero h1 span.accent {
            color: var(--aipa-rot);
        }

        .hero .subtitle {
            font-size: 1.1rem;
            color: var(--aipa-sekundaer);
            font-weight: 500;
            max-width: 700px;
            margin: 0 auto 1.5rem;
            line-height: 1.6;
        }

        .hero .date {
            font-size: 0.9rem;
            color: var(--aipa-sekundaer);
            font-weight: 500;
        }

        /* ── KPI Boxes in Hero ── */
        .kpi-container {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            margin: 1.5rem 0;
        }

        .kpi-box {
            background: var(--aipa-weiss);
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            text-align: center;
            min-width: 110px;
        }

        .kpi-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--aipa-rot);
            line-height: 1.2;
        }

        .kpi-label {
            font-size: 0.78rem;
            color: var(--aipa-sekundaer);
            margin-top: 0.2rem;
            font-weight: 500;
        }

        /* ── Page Layout: Sidebar + Content ── */
        .page-layout {
            display: flex;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 1.5rem;
            gap: 3rem;
        }

        /* ── Table of Contents (Sidebar) ── */
        .toc {
            width: 260px;
            flex-shrink: 0;
            position: sticky;
            top: 80px;
            align-self: flex-start;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        .toc h3 {
            font-size: 0.85rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--aipa-sekundaer);
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--aipa-rot);
        }

        .toc ul {
            list-style: none;
        }

        .toc li {
            margin-bottom: 0.25rem;
        }

        .toc a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: var(--aipa-blau-neutral);
            text-decoration: none;
            font-size: 0.82rem;
            font-weight: 500;
            border-radius: 4px;
            transition: all 0.2s;
            line-height: 1.4;
        }

        .toc a:hover {
            color: var(--aipa-rot);
            background: var(--aipa-hellgrau);
        }

        .toc a.active {
            color: var(--aipa-rot);
            background: var(--aipa-hellgrau);
            font-weight: 600;
        }

        /* ── Main Content ── */
        .main-content {
            flex: 1;
            min-width: 0;
            max-width: 860px;
        }

        /* ── Section Headings ── */
        .main-content h2 {
            font-size: 1.7rem;
            font-weight: 700;
            color: var(--aipa-schwarz);
            margin-top: 3rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--aipa-rot);
        }

        .main-content h2:first-child {
            margin-top: 0;
        }

        .main-content h3 {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--aipa-dunkelgrau);
            margin-top: 2rem;
            margin-bottom: 0.75rem;
        }

        .main-content h4 {
            font-size: 1.05rem;
            font-weight: 700;
            color: var(--aipa-dunkelgrau);
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
        }

        /* ── Paragraphs ── */
        .main-content p {
            margin-bottom: 1rem;
            color: var(--aipa-dunkelgrau);
        }

        /* ── Links ── */
        .main-content a {
            color: var(--aipa-rot);
            text-decoration: none;
            font-weight: 600;
            transition: color 0.2s;
        }

        .main-content a:hover {
            color: var(--aipa-hover-rot);
            text-decoration: underline;
        }

        /* ── Code Blocks ── */
        .main-content pre[class*="language-"] {
            background: var(--aipa-hellgrau) !important;
            color: var(--aipa-dunkelgrau) !important;
            border-left: 4px solid var(--aipa-rot);
            border-radius: 6px;
            padding: 1.25rem;
            margin: 1rem 0 1.5rem;
            overflow-x: auto;
            font-size: 0.88rem;
            line-height: 1.6;
        }

        .main-content pre[class*="language-"] code {
            background: none !important;
            color: var(--aipa-dunkelgrau) !important;
            font-size: 0.88rem;
        }

        /* Override Prism for light mode */
        .token.comment, .token.prolog, .token.doctype, .token.cdata { color: #6a737d !important; }
        .token.punctuation { color: #24292e !important; }
        .token.property, .token.tag, .token.boolean, .token.number, .token.constant, .token.symbol { color: #005cc5 !important; }
        .token.selector, .token.attr-name, .token.string, .token.char, .token.builtin { color: #032f62 !important; }
        .token.operator, .token.entity, .token.url { color: #d73a49 !important; }
        .token.atrule, .token.attr-value, .token.keyword { color: #d73a49 !important; }
        .token.function, .token.class-name { color: #6f42c1 !important; }
        .token.variable { color: #e36209 !important; }

        /* Inline code */
        .main-content code:not([class*="language-"]) {
            background: var(--aipa-hellgrau);
            color: var(--aipa-blau-neutral);
            padding: 0.15em 0.4em;
            border-radius: 4px;
            font-size: 0.9em;
            font-weight: 500;
        }

        /* ── Pipeline Flow (special styled block) ── */
        .pipeline-flow {
            background: var(--aipa-hellgrau);
            border-left: 4px solid var(--aipa-rot);
            padding: 1.25rem 1.5rem;
            border-radius: 6px;
            margin: 1rem 0 1.5rem;
            font-family: 'Montserrat', sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--aipa-dunkelgrau);
            text-align: center;
            letter-spacing: 0.01em;
            white-space: pre;
            line-height: 1.5;
        }

        /* ── Tables ── */
        .main-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0 1.5rem;
            font-size: 0.9rem;
        }

        .main-content table th {
            background: var(--aipa-blau-neutral);
            color: var(--aipa-weiss);
            font-weight: 700;
            padding: 0.75rem 1rem;
            text-align: left;
            font-size: 0.85rem;
        }

        .main-content table td {
            padding: 0.65rem 1rem;
            border-bottom: 1px solid var(--aipa-sekundaer-hell);
            color: var(--aipa-dunkelgrau);
        }

        .main-content table tr:nth-child(even) td {
            background: var(--aipa-hellgrau);
        }

        .main-content table tr:hover td {
            background: #eef0f4;
        }

        /* ── Lists ── */
        .main-content ul, .main-content ol {
            margin: 0.5rem 0 1.25rem 1.5rem;
        }

        .main-content li {
            margin-bottom: 0.4rem;
            color: var(--aipa-dunkelgrau);
        }

        .main-content li strong {
            color: var(--aipa-schwarz);
        }

        /* ── Mermaid Diagrams ── */
        .mermaid-wrapper {
            background: var(--aipa-hellgrau);
            border: 1px solid var(--aipa-sekundaer-hell);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            overflow-x: auto;
        }

        .mermaid-wrapper .mermaid {
            text-align: center;
        }

        .mermaid-caption {
            text-align: center;
            font-size: 0.85rem;
            color: var(--aipa-sekundaer);
            margin-top: 0.5rem;
            font-style: italic;
        }

        /* ── Strong ── */
        .main-content strong {
            font-weight: 700;
            color: var(--aipa-schwarz);
        }

        /* ── Horizontal Rule ── */
        .main-content hr {
            border: none;
            border-top: 1px solid var(--aipa-sekundaer-hell);
            margin: 2.5rem 0;
        }

        /* ── Info Box ── */
        .info-box {
            background: #f0f3f8;
            border-left: 4px solid var(--aipa-blau-neutral);
            padding: 1rem 1.25rem;
            border-radius: 0 6px 6px 0;
            margin: 1rem 0 1.5rem;
            font-size: 0.92rem;
        }

        .info-box strong {
            color: var(--aipa-blau-neutral);
        }

        /* ── Footer ── */
        .page-footer {
            background: var(--aipa-blau-neutral);
            color: var(--aipa-weiss);
            padding: 2.5rem 1.5rem;
            margin-top: 4rem;
        }

        .footer-inner {
            max-width: 860px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .footer-inner a {
            color: var(--aipa-weiss);
            text-decoration: none;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .footer-inner a:hover {
            opacity: 1;
        }

        .footer-brand {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .footer-brand img {
            height: 28px;
            width: auto;
            filter: brightness(0) invert(1);
        }

        .footer-brand span {
            font-weight: 700;
            font-size: 0.9rem;
        }

        .footer-meta {
            font-size: 0.8rem;
            opacity: 0.7;
        }

        /* ── Mobile TOC Toggle ── */
        .toc-mobile-toggle {
            display: none;
            position: fixed;
            bottom: 1.5rem;
            right: 1.5rem;
            z-index: 999;
            background: var(--aipa-rot);
            color: var(--aipa-weiss);
            border: none;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 4px 16px rgba(255,26,26,0.3);
            transition: background 0.2s;
        }

        .toc-mobile-toggle:hover {
            background: var(--aipa-hover-rot);
        }

        /* ── Responsive ── */
        @media (max-width: 900px) {
            .page-layout {
                flex-direction: column;
                padding: 1.5rem 1rem;
            }

            .toc {
                display: none;
                position: fixed;
                top: 64px;
                left: 0;
                right: 0;
                bottom: 0;
                width: 100%;
                max-height: none;
                background: var(--aipa-weiss);
                z-index: 998;
                padding: 1.5rem;
                overflow-y: auto;
                border-bottom: 1px solid var(--aipa-sekundaer-hell);
                box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            }

            .toc.mobile-open {
                display: block;
            }

            .toc-mobile-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .hero h1 {
                font-size: 1.6rem;
            }

            .hero .subtitle {
                font-size: 0.95rem;
            }

            .main-content h2 {
                font-size: 1.3rem;
            }

            .main-content table {
                font-size: 0.8rem;
            }

            .main-content table th, .main-content table td {
                padding: 0.5rem 0.6rem;
            }

            .kpi-container {
                gap: 0.6rem;
            }

            .kpi-box {
                padding: 0.7rem 1rem;
                min-width: 90px;
            }

            .kpi-value {
                font-size: 1.4rem;
            }

            .footer-inner {
                flex-direction: column;
                text-align: center;
            }
        }
    </style>
</head>
<body>

<!-- ═══════════════════════════════════════════════════════ -->
<!-- FIXED TOP NAVIGATION                                   -->
<!-- ═══════════════════════════════════════════════════════ -->
<nav class="top-nav">
    <div class="top-nav-inner">
        <a href="https://ai-pa.de" class="top-nav-logo">
            <img src="https://raw.githubusercontent.com/HolgerGelhausen/ai-performance-academy-assets/main/logo-cropped.png" alt="AIPA Logo">
            <span>AI Performance Academy</span>
        </a>
        <a href="https://ai-pa.ai/vortraege/" class="top-nav-back">&larr; Alle Vortr&auml;ge</a>
    </div>
</nav>

<!-- ═══════════════════════════════════════════════════════ -->
<!-- HERO SECTION                                           -->
<!-- ═══════════════════════════════════════════════════════ -->
<section class="hero">
    <div class="hero-inner">
        <h1>obs-f &mdash; Obsidian Vault Analyse mit <span class="accent">Fabric</span></h1>
        <p class="subtitle">8 Shell-Funktionen, FZF-Men&uuml;s und Fabric AI &mdash; komplette technische Anleitung zum Nachbauen deines Obsidian-Analyse-Tools.</p>

        <div class="kpi-container">
            <div class="kpi-box">
                <div class="kpi-value">8</div>
                <div class="kpi-label">Shell-Funktionen</div>
            </div>
            <div class="kpi-box">
                <div class="kpi-value">28</div>
                <div class="kpi-label">Fabric Patterns</div>
            </div>
            <div class="kpi-box">
                <div class="kpi-value">5</div>
                <div class="kpi-label">Rezept-Kategorien</div>
            </div>
            <div class="kpi-box">
                <div class="kpi-value">7</div>
                <div class="kpi-label">Diagramme</div>
            </div>
        </div>

        <p class="date">18.02.2026</p>
    </div>
</section>

<!-- ═══════════════════════════════════════════════════════ -->
<!-- PAGE LAYOUT: TOC Sidebar + Content                     -->
<!-- ═══════════════════════════════════════════════════════ -->
<div class="page-layout">

    <!-- ── Table of Contents (Sidebar) ── -->
    <aside class="toc" id="toc">
        <h3>Inhalt</h3>
        <ul>
            <li><a href="#was-macht-obs-f">Was macht obs-f?</a></li>
            <li><a href="#gesamtfluss">Gesamtfluss als Diagramm</a></li>
            <li><a href="#grundlagen">Grundlagen f&uuml;r Anf&auml;nger</a></li>
            <li><a href="#funktionen-ueberblick">Alle Funktionen im &Uuml;berblick</a></li>
            <li><a href="#fn1-obs-f">obs-f &ndash; Hauptfunktion</a></li>
            <li><a href="#fn2-collect">_obs_f_collect</a></li>
            <li><a href="#fn3-pick-pattern">_obs_f_pick_fabric_pattern</a></li>
            <li><a href="#fn4-run">_obs_f_run &ndash; Batch-Modus</a></li>
            <li><a href="#fn5-handoff">_obs_f_claude_handoff</a></li>
            <li><a href="#fn6-single">_obs_f_single</a></li>
            <li><a href="#fn7-pick-file">_obs_f_pick_file</a></li>
            <li><a href="#fn8-pick-tag">_obs_f_pick_tag</a></li>
            <li><a href="#eigene-patterns">Eigene Patterns</a></li>
            <li><a href="#globale-variablen">Globale Variablen</a></li>
            <li><a href="#minimal-setup">Minimal-Setup</a></li>
            <li><a href="#datei-uebersicht">Datei-&Uuml;bersicht</a></li>
        </ul>
    </aside>

    <!-- ── Mobile TOC Toggle Button ── -->
    <button class="toc-mobile-toggle" id="tocToggle" aria-label="Inhaltsverzeichnis anzeigen">&#9776;</button>

    <!-- ═══════════════════════════════════════════════════════ -->
    <!-- MAIN CONTENT                                           -->
    <!-- ═══════════════════════════════════════════════════════ -->
    <main class="main-content">

        <!-- ════════════════════════════════════════════════ -->
        <!-- Was macht obs-f?                                -->
        <!-- ════════════════════════════════════════════════ -->
        <h2 id="was-macht-obs-f">Was macht obs-f?</h2>

        <p><code>obs-f</code> ist ein Kommandozeilen-Tool, das du im Terminal tippst. Es macht 5 Dinge nacheinander:</p>

        <div class="pipeline-flow">obs-f
  |
  +-- 1. Rezept-Menue (FZF)     -> WELCHE Dateien aus deinem Obsidian Vault?
  |
  +-- 2. Pattern-Menue (FZF)    -> WAS soll Fabric damit machen?
  |
  +-- 3. Fabric laeuft           -> AI analysiert die Dateien (Ausgabe: Deutsch)
  |
  +-- 4. Output anzeigen         -> Du liest das Ergebnis im Terminal
  |
  +-- 5. Claude Handoff [j/N]    -> Optional: Claude Code uebernimmt</div>


        <!-- ════════════════════════════════════════════════ -->
        <!-- Gesamtfluss                                     -->
        <!-- ════════════════════════════════════════════════ -->
        <h2 id="gesamtfluss">Gesamtfluss als Diagramm</h2>

        <div class="mermaid-wrapper">
            <pre class="mermaid">
flowchart TD
    A["obs-f im Terminal tippen"] --> B["Rezept-Menue (FZF)"]
    B --> C{"Welcher Modus?"}
    C -->|"HEUTE/WOCHE/BATCH"| D["_obs_f_collect\nDateien sammeln"]
    C -->|"EINZELN"| E["_obs_f_pick_file\nDatei waehlen"]
    C -->|"__CMD__"| F["Shell-Befehl\nausfuehren"]
    D --> G["_obs_f_pick_fabric_pattern\nPattern-Menue (FZF)"]
    E --> G
    G --> H["Fabric AI\nAnalyse auf Deutsch"]
    H --> I["Output im Terminal\nanzeigen"]
    I --> J{"Weiter mit\nClaude Code?"}
    J -->|"j"| K["_obs_f_claude_handoff\nKontext-Datei schreiben\nClaude Code starten"]
    J -->|"N"| L["Fertig"]
            </pre>
            <p class="mermaid-caption">Abb. 1: Gesamtfluss &mdash; Vom Terminal-Aufruf zum Ergebnis</p>
        </div>


        <!-- ════════════════════════════════════════════════ -->
        <!-- Grundlagen                                      -->
        <!-- ════════════════════════════════════════════════ -->
        <h2 id="grundlagen">Grundlagen f&uuml;r Anf&auml;nger</h2>

        <h3>Was ist eine Shell-Funktion?</h3>

        <p>Eine Shell-Funktion ist ein wiederverwendbarer Code-Block in deinem Terminal. Statt lange Befehle zu tippen, gibst du nur den Funktionsnamen ein:</p>

        <pre><code class="language-bash"># Definition (in deiner .zshrc oder einer extra Datei)
meine_funktion() {
    echo "Hallo Welt"
}

# Aufruf
meine_funktion
# Ausgabe: Hallo Welt</code></pre>

        <p>Funktionen, die mit <code>_</code> beginnen (z.B. <code>_obs_f_run</code>), sind <strong>Helper</strong> &ndash; sie werden nicht direkt aufgerufen, sondern von anderen Funktionen benutzt.</p>

        <h3>Was ist FZF?</h3>

        <p><strong>FZF</strong> (Fuzzy Finder) ist ein Terminal-Tool, das interaktive Auswahl-Menues erzeugt. Du kennst Dropdown-Menues aus Websites &ndash; FZF ist das Gleiche, aber im Terminal.</p>

        <pre><code class="language-bash"># Installation
brew install fzf

# Einfachstes Beispiel: Datei waehlen
ls | fzf

# Mit Preview (zeigt Dateiinhalt rechts)
ls | fzf --preview="cat {}" --preview-window=right:50%</code></pre>

        <p><strong>Wichtige FZF-Flags, die obs-f nutzt:</strong></p>

        <table>
            <thead><tr><th>Flag</th><th>Was es tut</th><th>Beispiel</th></tr></thead>
            <tbody>
                <tr><td><code>--prompt</code></td><td>Text vor dem Suchfeld</td><td><code>--prompt="waehle > "</code></td></tr>
                <tr><td><code>--header</code></td><td>Ueberschrift oben im Menue</td><td><code>--header="Fabric Patterns"</code></td></tr>
                <tr><td><code>--preview</code></td><td>Shell-Befehl, der rechts ausgefuehrt wird</td><td><code>--preview="cat {}"</code></td></tr>
                <tr><td><code>--preview-window</code></td><td>Wo/wie gross die Preview ist</td><td><code>--preview-window=right:50%:wrap</code></td></tr>
                <tr><td><code>--height</code></td><td>Wie viel Terminal-Hoehe FZF nutzt</td><td><code>--height=80%</code></td></tr>
                <tr><td><code>--border</code></td><td>Rahmen um das Menue</td><td><code>--border=rounded</code></td></tr>
                <tr><td><code>--no-multi</code></td><td>Nur 1 Auswahl erlaubt</td><td><code>--no-multi</code></td></tr>
                <tr><td><code>--reverse</code></td><td>Liste von oben nach unten</td><td><code>--reverse</code></td></tr>
                <tr><td><code>--ansi</code></td><td>Farbcodes in der Liste erlauben</td><td><code>--ansi</code></td></tr>
                <tr><td><code>--delimiter</code></td><td>Trennzeichen fuer Spalten</td><td><code>--delimiter='|'</code></td></tr>
                <tr><td><code>--with-nth</code></td><td>Nur bestimmte Spalten anzeigen</td><td><code>--with-nth=2</code></td></tr>
                <tr><td><code>--no-info</code></td><td>Keine Zaehler-Zeile unten</td><td><code>--no-info</code></td></tr>
            </tbody>
        </table>

        <h3>Was ist Fabric?</h3>

        <p><strong>Fabric</strong> ist ein CLI-Tool von Daniel Miessler. Es hat ueber 200 vordefinierte AI-Analyse-Patterns. Jedes Pattern ist ein Ordner mit einer <code>system.md</code> Datei &ndash; einem System-Prompt.</p>

        <pre><code class="language-bash"># Installation
go install github.com/danielmiessler/fabric@latest
# oder auf macOS:
brew install fabric-ai

# Einfachstes Beispiel: Text zusammenfassen
echo "Langer Text..." | fabric -p summarize

# Pattern-Liste anzeigen
ls ~/.config/fabric/patterns/</code></pre>

        <p><strong>Wie ein Pattern aufgebaut ist:</strong></p>

        <pre><code class="language-text">~/.config/fabric/patterns/
  extract_wisdom/
    system.md          &larr; Das ist der System-Prompt
  summarize/
    system.md
  analyze_prose/
    system.md
  ... (239 weitere)</code></pre>

        <p>Die <code>system.md</code> enthaelt Anweisungen fuer die AI, z.B.:</p>

        <pre><code class="language-markdown"># IDENTITY and PURPOSE
You are a wisdom extraction service...

# STEPS
1. Extract surprising insights
2. Find the most important ideas
...

# OUTPUT FORMAT
- Use markdown
- Section: IDEAS, INSIGHTS, QUOTES...</code></pre>

        <h3>Was ist ein Heredoc?</h3>

        <p>Ein Heredoc (<code>&lt;&lt;EOF ... EOF</code>) schreibt mehrzeiligen Text in eine Datei oder Variable. obs-f nutzt es fuer die Kontext-Datei:</p>

        <pre><code class="language-bash">cat > datei.md &lt;&lt;EOF
# Ueberschrift
Inhalt mit $variablen die ersetzt werden.
EOF</code></pre>

        <h3>Was ist eine Pipe?</h3>

        <p>Die Pipe (<code>|</code>) schickt die Ausgabe eines Befehls als Eingabe an den naechsten:</p>

        <pre><code class="language-bash"># Dateien sammeln -> an Fabric schicken
cat datei1.md datei2.md | fabric -p summarize
#     ^ Output              ^ wird hier Input</code></pre>

        <h3>Was ist Obsidian CLI?</h3>

        <p><strong>Obsidian CLI</strong> ist eine Kommandozeilen-Schnittstelle, die ab Obsidian v1.12 verfuegbar ist. Sie erlaubt dir, JavaScript direkt in Obsidians Metadata Cache auszufuehren &ndash; also Dateien, Tags und Frontmatter abzufragen, ohne das Dateisystem direkt durchsuchen zu muessen.</p>

        <p><strong>Warum ist das wichtig fuer obs-f?</strong> Obsidian hat einen internen Cache aller Dateien mit Metadaten (Tags, Frontmatter, Aenderungsdatum). Ueber die CLI kann obs-f diesen Cache in Millisekunden abfragen, statt tausende Dateien per <code>find</code> zu durchsuchen.</p>

        <h4>Installation</h4>

        <p><strong>Voraussetzung:</strong> Obsidian v1.12 oder neuer.</p>

        <p><strong>macOS (einmalig):</strong></p>

        <pre><code class="language-bash"># Obsidian-Binary zum PATH hinzufuegen
echo 'export PATH="/Applications/Obsidian.app/Contents/MacOS:$PATH"' >> ~/.zprofile

# Terminal neu starten oder:
source ~/.zprofile

# Testen
obsidian --version</code></pre>

        <p><strong>Linux:</strong></p>

        <pre><code class="language-bash"># AppImage: Obsidian binary ist im AppImage enthalten
# Flatpak: flatpak run md.obsidian.Obsidian --help
echo 'alias obsidian="/pfad/zu/obsidian"' >> ~/.bashrc</code></pre>

        <h4>Wie obs-f die CLI nutzt</h4>

        <p>obs-f verwendet den <code>eval</code>-Befehl, um JavaScript in Obsidian auszufuehren:</p>

        <pre><code class="language-bash"># Grundsyntax
obsidian eval --vault "MeinVault" --code 'JavaScript-Code'

# Beispiel: Alle heutigen Markdown-Dateien auflisten
obsidian eval --vault "Akademie" --code 'JSON.stringify(
    app.vault.getFiles()
        .filter(f => f.extension === "md" && f.stat.mtime > Date.now() - 86400000)
        .map(f => f.path)
)'</code></pre>

        <p><strong>Wichtige Objekte im eval-Kontext:</strong></p>

        <table>
            <thead><tr><th>Objekt</th><th>Zugriff auf</th><th>Beispiel</th></tr></thead>
            <tbody>
                <tr><td><code>app.vault</code></td><td>Alle Dateien im Vault</td><td><code>app.vault.getFiles()</code></td></tr>
                <tr><td><code>app.metadataCache</code></td><td>Tags, Frontmatter, Links</td><td><code>app.metadataCache.getTags()</code></td></tr>
                <tr><td><code>f.stat.mtime</code></td><td>Aenderungszeitpunkt (Unix-ms)</td><td><code>f.stat.mtime > 1708300800000</code></td></tr>
                <tr><td><code>f.extension</code></td><td>Dateiendung</td><td><code>f.extension === 'md'</code></td></tr>
                <tr><td><code>f.path</code></td><td>Relativer Pfad im Vault</td><td><code>f.path.includes('Marketing')</code></td></tr>
            </tbody>
        </table>

        <p><strong>Der <code>_obs_eval</code> Helper:</strong></p>

        <pre><code class="language-bash">_obs_eval() {
    local vault="$1" code="$2"
    obsidian eval --vault "$(basename "$vault")" --code "$code" 2>/dev/null
}</code></pre>

        <p>Wenn Obsidian CLI nicht verfuegbar ist, faellt obs-f automatisch auf Filesystem-Suche mit <code>find</code> zurueck (siehe Funktion 2).</p>

        <h4>Obsidian CLI Diagramm</h4>

        <div class="mermaid-wrapper">
            <pre class="mermaid">
flowchart LR
    A["obs-f Funktion"] --> B["_obs_eval Helper"]
    B --> C["obsidian eval --vault --code"]
    C --> D["Obsidian Metadata Cache"]
    D --> E["JSON-Array mit Dateipfaden"]
    E --> F["obs-f verarbeitet Ergebnis"]

    style D fill:#e6f3ff,stroke:#0066cc,stroke-width:2px
            </pre>
            <p class="mermaid-caption">Abb. 2: Obsidian CLI &mdash; Vom Funktionsaufruf zum Metadata Cache</p>
        </div>


        <!-- ════════════════════════════════════════════════ -->
        <!-- Funktionen Ueberblick                           -->
        <!-- ════════════════════════════════════════════════ -->
        <h2 id="funktionen-ueberblick">Alle Shell-Funktionen im &Uuml;berblick</h2>

        <p>obs-f besteht aus <strong>8 Funktionen</strong>. Hier ist die Aufruf-Hierarchie:</p>

        <div class="pipeline-flow">obs-f()                          &larr; Hauptfunktion (du tippst das)
  |
  +-- _obs_f_pick_tag()           &larr; Tag/Ordner-Filter per FZF
  |
  +-- _obs_f_single()             &larr; Einzeldatei-Modus
  |   +-- _obs_f_pick_file()      &larr; Datei waehlen per FZF
  |   +-- _obs_f_pick_fabric_pattern()  &larr; Pattern waehlen per FZF
  |   +-- _obs_f_claude_handoff() &larr; Claude Code Uebergabe
  |
  +-- _obs_f_run()                &larr; Batch-Modus (mehrere Dateien)
      +-- _obs_f_collect()        &larr; Dateien nach Zeit/Filter sammeln
      +-- _obs_f_pick_fabric_pattern()  &larr; Pattern waehlen per FZF
      +-- _obs_f_claude_handoff() &larr; Claude Code Uebergabe</div>

        <h3>Funktions-Hierarchie als Diagramm</h3>

        <div class="mermaid-wrapper">
            <pre class="mermaid">
flowchart TD
    OBS["obs-f\nHauptfunktion"] --> TAG["_obs_f_pick_tag\nTag/Ordner-Filter"]
    OBS --> SINGLE["_obs_f_single\nEinzeldatei-Modus"]
    OBS --> RUN["_obs_f_run\nBatch-Modus"]

    SINGLE --> PICK["_obs_f_pick_file\nDatei waehlen"]
    SINGLE --> PAT1["_obs_f_pick_fabric_pattern\nPattern waehlen"]
    SINGLE --> HAND1["_obs_f_claude_handoff\nClaude Uebergabe"]

    RUN --> COLL["_obs_f_collect\nDateien sammeln"]
    RUN --> PAT2["_obs_f_pick_fabric_pattern\nPattern waehlen"]
    RUN --> HAND2["_obs_f_claude_handoff\nClaude Uebergabe"]

    COLL --> EVAL["_obs_eval\nObsidian CLI"]

    style OBS fill:#4CAF50,stroke:#2E7D32,color:#fff,stroke-width:3px
    style PAT1 fill:#FF9800,stroke:#E65100,color:#fff
    style PAT2 fill:#FF9800,stroke:#E65100,color:#fff
    style HAND1 fill:#2196F3,stroke:#0D47A1,color:#fff
    style HAND2 fill:#2196F3,stroke:#0D47A1,color:#fff
            </pre>
            <p class="mermaid-caption">Abb. 3: Funktions-Hierarchie &mdash; 8 Funktionen und ihre Abh&auml;ngigkeiten</p>
        </div>


        <!-- ════════════════════════════════════════════════ -->
        <!-- Funktion 1: obs-f                               -->
        <!-- ════════════════════════════════════════════════ -->
        <h2 id="fn1-obs-f">Funktion 1: <code>obs-f</code> &ndash; Hauptfunktion</h2>

        <p><strong>Was sie tut:</strong> Zeigt das Rezept-Menue, parst die Auswahl und ruft den richtigen Helper auf.</p>
        <p><strong>Aufgerufen durch:</strong> Dich im Terminal.</p>

        <h3>Das Rezept-Array</h3>

        <p>Das Herzstuck ist ein Array aus Pipe-getrennten Strings. Jeder String ist ein Rezept:</p>

        <pre><code class="language-bash">local recipes=(
    "HEUTE|Zusammenfassung|Alle heutigen Dateien zusammenfassen|today||summarize"
    "HEUTE|Learnings|Key Insights von heute extrahieren|today||extract_wisdom"
    "HEUTE|Nur Marketing|Heutige Marketing-Dateien|today|marketing|summarize"
    "HEUTE|Nach Tag...|Tag waehlen -> heutige Dateien|today|__TAG__|summarize"
    "WOCHE|Zusammenfassung|7-Tage Ueberblick|week||summarize"
    "BATCH|Letzte 10|Die 10 neuesten zusammenfassen|recent||summarize|10"
    "EINZELN|Datei -> Pattern|Datei waehlen, dann Pattern|__SINGLE__|||"
    "CLAUDE|Heute|Claude Conversations von heute|today||summarize"
    "VAULT|Conversations aufraeumen|obs-ai-digest --batch 10|__CMD__|obs-ai-digest --batch 10||"
)</code></pre>

        <p><strong>Format:</strong> <code>KATEGORIE|NAME|BESCHREIBUNG|MODUS|FILTER|PATTERN[|LIMIT]</code></p>

        <table>
            <thead><tr><th>Feld</th><th>Bedeutung</th><th>Beispielwerte</th></tr></thead>
            <tbody>
                <tr><td>KATEGORIE</td><td>Gruppe im FZF-Menue</td><td><code>HEUTE</code>, <code>WOCHE</code>, <code>BATCH</code>, <code>EINZELN</code>, <code>CLAUDE</code>, <code>VAULT</code></td></tr>
                <tr><td>NAME</td><td>Anzeigename</td><td><code>Zusammenfassung</code>, <code>Learnings</code></td></tr>
                <tr><td>BESCHREIBUNG</td><td>Erklaerungstext</td><td><code>Alle heutigen Dateien zusammenfassen</code></td></tr>
                <tr><td>MODUS</td><td>Zeitfilter fuer <code>_obs_f_collect</code></td><td><code>today</code>, <code>week</code>, <code>recent</code>, <code>__SINGLE__</code>, <code>__CMD__</code></td></tr>
                <tr><td>FILTER</td><td>Ordner- oder Tag-Filter</td><td>leer, <code>marketing</code>, <code>kurse</code>, <code>__TAG__</code></td></tr>
                <tr><td>PATTERN</td><td>Fabric-Pattern</td><td><code>summarize</code>, <code>extract_wisdom</code></td></tr>
                <tr><td>LIMIT</td><td>Max. Dateien (optional)</td><td><code>10</code>, <code>20</code></td></tr>
            </tbody>
        </table>

        <p><strong>Spezial-Modi:</strong></p>

        <table>
            <thead><tr><th>Modus</th><th>Verhalten</th></tr></thead>
            <tbody>
                <tr><td><code>__SINGLE__</code></td><td>Ruft <code>_obs_f_single()</code> auf &ndash; Einzeldatei-Modus</td></tr>
                <tr><td><code>__CMD__</code></td><td>Fuehrt den FILTER-Wert als Shell-Befehl aus</td></tr>
                <tr><td><code>__TAG__</code></td><td>Oeffnet <code>_obs_f_pick_tag()</code> zur Tag-Auswahl</td></tr>
            </tbody>
        </table>

        <h3>Das Display bauen</h3>

        <pre><code class="language-bash"># Feste Spaltenbreiten mit printf
printf '  %-10s  %-24s  %s' "$cat" "$name" "$desc"
# Ergibt z.B.: "  HEUTE       Zusammenfassung           Alle heutigen Dateien"</code></pre>

        <p>Kategorien werden mit Trennlinien gruppiert:</p>

        <pre><code class="language-bash">if [[ "$cat" != "$last_cat" ]]; then
    display_lines+=("--- ${cat} ---")
    last_cat="$cat"
fi</code></pre>

        <h3>Rezept parsen</h3>

        <p>Nach der FZF-Auswahl wird das Rezept in seine Bestandteile zerlegt:</p>

        <pre><code class="language-bash"># Zsh parameter expansion: ${var%%|*} = alles VOR dem ersten |
#                          ${var#*|}  = alles NACH dem ersten |

local _r="$found_recipe"
local _skip="${_r%%|*}"; _r="${_r#*|}"   # CAT (uebersprungen)
_skip="${_r%%|*}"; _r="${_r#*|}"          # NAME (uebersprungen)
_skip="${_r%%|*}"; _r="${_r#*|}"          # DESC (uebersprungen)
local r_mode="${_r%%|*}"; _r="${_r#*|}"   # today/week/recent
local r_filter="${_r%%|*}"; _r="${_r#*|}" # marketing/kurse/...
local r_pattern="${_r%%|*}"               # summarize/extract_wisdom</code></pre>

        <div class="info-box">
            <strong>Warum nicht einfach <code>IFS='|' read</code>?</strong> In Zsh funktioniert <code>IFS='|'</code> beim Splitting anders als in Bash. Die <code>${var%%|*}</code> / <code>${var#*|}</code> Methode ist zuverlaessiger.
        </div>

        <h3>FZF Spalten-Extraktion</h3>

        <pre><code class="language-bash"># printf '  %-10s  %-24s  %s' erzeugt feste Spalten:
# Zeichen  3-12 = Kategorie (10 Zeichen)
# Zeichen 15-38 = Name (24 Zeichen)

local sel_cat=$(echo "$selection" | cut -c3-12 | sed 's/[[:space:]]*$//')
local sel_name=$(echo "$selection" | cut -c15-38 | sed 's/[[:space:]]*$//')</code></pre>


        <!-- ════════════════════════════════════════════════ -->
        <!-- Funktion 2: _obs_f_collect                      -->
        <!-- ════════════════════════════════════════════════ -->
        <h2 id="fn2-collect">Funktion 2: <code>_obs_f_collect</code> &ndash; Dateien sammeln</h2>

        <p><strong>Was sie tut:</strong> Liefert Dateipfade basierend auf Zeitraum und Filter.</p>
        <p><strong>Aufgerufen durch:</strong> <code>_obs_f_run()</code></p>

        <table>
            <thead><tr><th>#</th><th>Name</th><th>Werte</th><th>Beispiel</th></tr></thead>
            <tbody>
                <tr><td>$1</td><td>mode</td><td><code>today</code>, <code>week</code>, <code>recent</code></td><td><code>today</code></td></tr>
                <tr><td>$2</td><td>filter</td><td>Ordnername oder Tag</td><td><code>marketing</code></td></tr>
                <tr><td>$3</td><td>limit</td><td>Max. Dateien</td><td><code>10</code></td></tr>
                <tr><td>$4</td><td>include_claude</td><td><code>0</code>/<code>1</code>/<code>only</code></td><td><code>0</code></td></tr>
            </tbody>
        </table>

        <h3>Primaerer Weg: Obsidian CLI eval</h3>

        <pre><code class="language-bash">local js_code="JSON.stringify(
    app.vault.getFiles()
        .filter(f =>
            f.extension === 'md'
            && !f.path.includes('_Archive')
            && !f.path.includes('_templates')
            && !f.path.includes('.obsidian')
            ${js_claude_filter}      # Conversations ein/aus
            ${js_time_filter}        # Heute/Woche/alle
            ${js_path_filter}        # Ordner-Filter
        )
        .sort((a,b) => b.stat.mtime - a.stat.mtime)
        ${js_limit}                  # .slice(0, N)
        .map(f => f.path)
)"

local result=$(_obs_eval "$vault" "$js_code")</code></pre>

        <p><strong>Zeitfilter (JavaScript):</strong></p>

        <pre><code class="language-bash">case "$mode" in
    today)
        local today_start_ms=$(date -j -f "%Y-%m-%d %H:%M:%S" \
            "$(date +%Y-%m-%d) 00:00:00" "+%s" 2>/dev/null)000
        js_time_filter="&&f.stat.mtime>${today_start_ms}"
        ;;
    week)
        local week_ms=$(( $(date +%s) - 7 * 86400 ))000
        js_time_filter="&&f.stat.mtime>${week_ms}"
        ;;
esac</code></pre>

        <p><strong>Ordner-Filter (JavaScript):</strong></p>

        <pre><code class="language-bash">case "$filter" in
    marketing)  js_path_filter="&&f.path.includes('20_Marketing')" ;;
    kurse)      js_path_filter="&&f.path.includes('10_Kurse')" ;;
    wissen)     js_path_filter="&&f.path.includes('30_Wissen')" ;;
    strategie)  js_path_filter="&&f.path.includes('50_strategie')" ;;
    *)
        # Tag-basierter Filter via Metadata Cache
        js_path_filter="&&(()=>{
            const c=app.metadataCache.getFileCache(f);
            const t=c?.frontmatter?.tags;
            return Array.isArray(t)
                ? t.some(x=>x.toLowerCase().includes('${filter}'))
                : typeof t==='string' && t.includes('${filter}')
        })()"
        ;;
esac</code></pre>

        <h3>Fallback: Filesystem</h3>

        <pre><code class="language-bash">case "$mode" in
    today)
        find "$vault" -name '*.md' -type f | while IFS= read -r ff; do
            [[ "$(stat -f '%Sm' -t '%Y-%m-%d' "$ff")" == "$today" ]] && echo "$ff"
        done
        ;;
    week)
        find "$vault" -name '*.md' -type f -mtime -7
        ;;
    recent)
        find "$vault" -name '*.md' -type f \
            -exec stat -f '%m|%N' {} \; | sort -rn | head -${limit} | cut -d'|' -f2
        ;;
esac</code></pre>

        <h3>Entscheidungsbaum</h3>

        <div class="mermaid-wrapper">
            <pre class="mermaid">
flowchart TD
    START["_obs_f_collect aufgerufen"] --> CLI{"Obsidian CLI\nverfuegbar?"}
    CLI -->|"Ja"| EVAL["_obs_eval: JavaScript\nim Metadata Cache"]
    CLI -->|"Nein"| FS["Fallback:\nFilesystem mit find"]

    EVAL --> MODE{"mode Parameter?"}
    FS --> MODE2{"mode Parameter?"}

    MODE -->|"today"| T1["mtime > heute 00:00\nals Unix-ms"]
    MODE -->|"week"| W1["mtime > vor 7 Tagen\nals Unix-ms"]
    MODE -->|"recent"| R1["Alle Dateien\n.slice 0 bis limit"]

    MODE2 -->|"today"| T2["stat Datum == heute"]
    MODE2 -->|"week"| W2["find -mtime -7"]
    MODE2 -->|"recent"| R2["stat + sort + head"]

    T1 --> FILTER{"filter\ngesetzt?"}
    W1 --> FILTER
    R1 --> FILTER

    FILTER -->|"Ordner"| PATH["path.includes\nz.B. 20_Marketing"]
    FILTER -->|"Tag"| META["metadataCache\nfrontmatter.tags"]
    FILTER -->|"Leer"| ALL["Alle passenden\nDateien"]

    PATH --> OUT["JSON-Array\nmit Pfaden"]
    META --> OUT
    ALL --> OUT

    style EVAL fill:#4CAF50,stroke:#2E7D32,color:#fff
    style FS fill:#FF9800,stroke:#E65100,color:#fff
            </pre>
            <p class="mermaid-caption">Abb. 4: Entscheidungsbaum &mdash; Obsidian CLI vs. Filesystem Fallback</p>
        </div>


        <!-- ════════════════════════════════════════════════ -->
        <!-- Funktion 3: _obs_f_pick_fabric_pattern          -->
        <!-- ════════════════════════════════════════════════ -->
        <h2 id="fn3-pick-pattern">Funktion 3: <code>_obs_f_pick_fabric_pattern</code> &ndash; Pattern w&auml;hlen</h2>

        <p><strong>Was sie tut:</strong> Zeigt ein FZF-Menue mit 28 kuratierten Fabric-Patterns in 7 Kategorien.</p>
        <p><strong>Gibt zurueck:</strong> Den Pattern-Namen als String (z.B. <code>extract_wisdom</code>)</p>

        <h3>Vollstaendiger Code</h3>

        <pre><code class="language-bash">_obs_f_pick_fabric_pattern() {
    local PATTERNS_DIR="$HOME/.config/fabric/patterns"

    local -a CURATED=(
        "-- ANALYSIEREN & ERKLAEREN ---|"
        "extract_wisdom               | Weisheit, Ideen, Zitate extrahieren"
        "extract_insights             | Die 10 ueberraschendsten Kernerkenntnisse"
        "analyze_prose                | Schreibqualitaet bewerten"
        "analyze_claims               | Behauptungen pruefen (A-F Rating)"
        "analyze_paper                | Wissenschaftliche Rigor-Analyse"
        "analyze_presentation         | Praesentation kritisch bewerten"
        "analyze_tech_impact          | Technologie-Impact analysieren"
        "find_logical_fallacies       | Logikfehler finden"
        "explain_docs                 | Dokumentation erklaeren"
        "explain_terms                | Glossar erstellen"
        "rate_content                 | Qualitaets-Rating (1-10)"
        "-- ZUSAMMENFASSEN ------------|"
        "summarize                    | 1-Satz-Summary + 10 Hauptpunkte"
        "create_summary               | Strukturierte Zusammenfassung"
        "create_5_sentence_summary    | 5-Satz-Zusammenfassung"
        "extract_core_message         | Kernbotschaft auf den Punkt"
        "-- VERGLEICHEN ---------------|"
        "compare_and_contrast         | Gemeinsamkeiten & Unterschiede"
        "-- CONTENT ERSTELLEN ---------|"
        "write_essay                  | Essay im Paul-Graham-Stil"
        "create_keynote               | Keynote erstellen"
        "write_micro_essay            | Micro-Essay (< 300 Woerter)"
        "improve_writing              | Text ueberarbeiten"
        "enrich_blog_post             | Blog-Post verbessern"
        "create_newsletter_entry      | Newsletter-Abschnitt"
        "-- EXTRAHIEREN ---------------|"
        "extract_ideas                | 20-50 ueberraschende Ideen"
        "extract_recommendations      | Handlungsempfehlungen"
        "extract_questions            | Offene Fragen identifizieren"
        "create_tags                  | Tags generieren"
        "-- LERNEN --------------------|"
        "create_flash_cards           | Lernkarten erstellen"
        "create_quiz                  | Quiz-Fragen generieren"
        "-- ALLE ----------------------|"
        "ALLE_PATTERNS                | Alle Fabric Patterns durchsuchen"
    )

    local choice
    choice=$(printf '%s\n' "${CURATED[@]}" | fzf \
        --prompt="Pattern waehlen > " \
        --header="Fabric Pattern fuer die Analyse" \
        --preview='p=$(echo {} | awk "{print \$1}");
                  f="'"$PATTERNS_DIR"'/$p/system.md";
                  if [[ -f "$f" ]]; then
                    printf "\033[1;33m-- %s --\033[0m\n\n" "$p"
                    head -30 "$f"
                  else
                    echo "Kategorie-Header"
                  fi' \
        --preview-window=right:50%:wrap \
        --height=80% --border=rounded --no-multi)

    [[ -z "$choice" ]] && return 1
    local selected=$(echo "$choice" | awk '{print $1}')
    [[ "$selected" == "--" ]] && return 1

    if [[ "$selected" == "ALLE_PATTERNS" ]]; then
        selected=$(ls "$PATTERNS_DIR" | fzf \
            --prompt="Pattern suchen > " \
            --header="Alle Fabric Patterns durchsuchen" \
            --preview='...' \
            --preview-window=right:50%:wrap \
            --height=80% --border=rounded --no-multi)
        [[ -z "$selected" ]] && return 1
    fi

    echo "$selected"
}</code></pre>

        <h3>Die 7 Pattern-Kategorien</h3>

        <div class="mermaid-wrapper">
            <pre class="mermaid">
mindmap
  root((Fabric Patterns))
    Analysieren
      extract_wisdom
      extract_insights
      analyze_prose
      analyze_claims
      find_logical_fallacies
      rate_content
    Zusammenfassen
      summarize
      create_summary
      create_5_sentence_summary
      extract_core_message
    Vergleichen
      compare_and_contrast
    Content Erstellen
      write_essay
      create_keynote
      improve_writing
      enrich_blog_post
    Extrahieren
      extract_ideas
      extract_recommendations
      extract_questions
      create_tags
    Lernen
      create_flash_cards
      create_quiz
    Alle
      ALLE_PATTERNS
            </pre>
            <p class="mermaid-caption">Abb. 5: Die 7 Pattern-Kategorien mit allen 28 kuratierten Patterns</p>
        </div>


        <!-- ════════════════════════════════════════════════ -->
        <!-- Funktion 4: _obs_f_run                          -->
        <!-- ════════════════════════════════════════════════ -->
        <h2 id="fn4-run">Funktion 4: <code>_obs_f_run</code> &ndash; Batch-Modus</h2>

        <p><strong>Was sie tut:</strong> Sammelt Dateien, oeffnet Pattern-FZF, laesst Fabric laufen, bietet Claude Handoff an.</p>

        <h3>Vollstaendiger Code</h3>

        <pre><code class="language-bash">_obs_f_run() {
    local mode="$1" filter="$2" pattern="$3" limit="${4:-0}" include_claude="${5:-0}"

    # --- Dateien sammeln ---
    local files=()
    while IFS= read -r f; do
        [[ -n "$f" ]] && files+=("$f")
    done < <(_obs_f_collect "$mode" "$filter" "$limit" "$include_claude")

    if [[ ${#files[@]} -eq 0 ]]; then
        echo "Keine Dateien gefunden."
        return 1
    fi

    echo "${#files[@]} Dateien gesammelt"

    # --- Pattern waehlen via FZF ---
    pattern=$(_obs_f_pick_fabric_pattern)
    [[ $? -ne 0 || -z "$pattern" ]] && { echo "Abgebrochen."; return 0; }

    echo "Fabric: ${pattern} (deutsch) ..."

    # --- Alle Dateien durch Fabric schicken ---
    local fabric_output
    fabric_output=$({
        echo "WICHTIG: Antworte komplett auf Deutsch."
        echo ""
        for f in "${files[@]}"; do
            printf '\n\n--- %s ---\n\n' "$(basename "$f" .md)"
            cat "$f" 2>/dev/null
        done
    } | "$_OBS_FABRIC_BIN" -p "$pattern")

    echo "$fabric_output"
    _obs_f_claude_handoff "$fabric_output" "$pattern" "${#files[@]}"
}</code></pre>

        <h3>Datenfluss durch die Fabric-Pipe</h3>

        <div class="mermaid-wrapper">
            <pre class="mermaid">
flowchart LR
    DE["Deutsch-Instruktion\nWICHTIG: Antworte\nauf Deutsch"] --> PIPE["Pipe"]
    F1["Datei 1\n--- name1 ---\nInhalt"] --> PIPE
    F2["Datei 2\n--- name2 ---\nInhalt"] --> PIPE
    F3["Datei N\n--- nameN ---\nInhalt"] --> PIPE

    PIPE --> FAB["fabric -p pattern\nz.B. extract_wisdom"]
    FAB --> OUT["Fabric Output\nStrukturierte Analyse\nauf Deutsch"]
    OUT --> TERM["Terminal-Ausgabe"]
    OUT --> CTX["Kontext-Datei\nobs-f-context.md"]
    CTX --> CC["Claude Code"]

    style FAB fill:#9C27B0,stroke:#4A148C,color:#fff,stroke-width:3px
    style CC fill:#2196F3,stroke:#0D47A1,color:#fff
            </pre>
            <p class="mermaid-caption">Abb. 6: Datenfluss &mdash; Von der Deutsch-Instruktion &uuml;ber Fabric bis Claude Code</p>
        </div>


        <!-- ════════════════════════════════════════════════ -->
        <!-- Funktion 5: _obs_f_claude_handoff               -->
        <!-- ════════════════════════════════════════════════ -->
        <h2 id="fn5-handoff">Funktion 5: <code>_obs_f_claude_handoff</code> &ndash; Claude Code &Uuml;bergabe</h2>

        <p><strong>Was sie tut:</strong> Fragt "Weiter mit Claude Code? [j/N]". Bei ja: schreibt Output in eine Datei und startet Claude Code.</p>

        <pre><code class="language-bash">_obs_f_claude_handoff() {
    local output="$1" pattern="$2" file_count="$3"

    echo ""
    printf "  -> Weiter mit Claude Code? [j/N] "
    read -k1 answer       # Zsh: genau 1 Zeichen lesen
    echo ""

    [[ "$answer" != [jJyY] ]] && return 0

    # Kontext-Datei schreiben
    local ctx_file="$HOME/PAI/PAI_DIRECTORY/.state/obs-f-context.md"
    mkdir -p "$(dirname "$ctx_file")"
    cat > "$ctx_file" &lt;&lt;CTXEOF
# Fabric-Analyse: $pattern
**Dateien:** $file_count | **Zeitpunkt:** $(date '+%H:%M %d.%m.%Y')

---

$output
CTXEOF

    echo "  Claude Code startet..."
    claude "Lies die Datei $ctx_file - das ist eine Fabric-Analyse \
($pattern) meines Obsidian Vaults. Hilf mir basierend auf dieser Analyse weiter."
}</code></pre>

        <div class="info-box">
            <strong>Warum Kontext-Datei statt Inline?</strong> Shell-Argumente haben eine Laengenbegrenzung (~262.144 Zeichen auf macOS). Die Kontext-Datei hat keine Groessenbegrenzung.
        </div>

        <h3>Claude Handoff Ablauf</h3>

        <div class="mermaid-wrapper">
            <pre class="mermaid">
flowchart TD
    Q["Weiter mit Claude Code?\nread -k1 answer"] --> D{"Antwort?"}
    D -->|"j/J/y/Y"| WRITE["Kontext-Datei schreiben\nobs-f-context.md"]
    D -->|"Alles andere"| STOP["return 0\nFertig"]

    WRITE --> CONTENT["Heredoc mit\nPattern + Dateianzahl\n+ Zeitstempel\n+ Fabric Output"]
    CONTENT --> START["claude Befehl\nmit Verweis auf\nKontext-Datei"]
    START --> CC["Claude Code\nliest Datei\nund hilft weiter"]

    style Q fill:#FF9800,stroke:#E65100,color:#fff
    style CC fill:#2196F3,stroke:#0D47A1,color:#fff
            </pre>
            <p class="mermaid-caption">Abb. 7: Claude Handoff &mdash; Vom User-Prompt zur Claude Code Session</p>
        </div>


        <!-- ════════════════════════════════════════════════ -->
        <!-- Funktion 6: _obs_f_single                       -->
        <!-- ════════════════════════════════════════════════ -->
        <h2 id="fn6-single">Funktion 6: <code>_obs_f_single</code> &ndash; Einzeldatei-Modus</h2>

        <p><strong>Aufgerufen durch:</strong> <code>obs-f()</code> bei <code>__SINGLE__</code>-Rezepten.</p>

        <pre><code class="language-bash">_obs_f_single() {
    local pattern="$1"
    local file=$(_obs_f_pick_file)
    [[ -z "$file" ]] && return 0

    pattern=$(_obs_f_pick_fabric_pattern)
    [[ $? -ne 0 || -z "$pattern" ]] && return 0

    local fabric_output
    fabric_output=$({
        echo "WICHTIG: Antworte komplett auf Deutsch."
        echo ""
        cat "$file"
    } | "$_OBS_FABRIC_BIN" -p "$pattern")

    echo "$fabric_output"
    _obs_f_claude_handoff "$fabric_output" "$pattern" "1"
}</code></pre>


        <!-- ════════════════════════════════════════════════ -->
        <!-- Funktion 7: _obs_f_pick_file                    -->
        <!-- ════════════════════════════════════════════════ -->
        <h2 id="fn7-pick-file">Funktion 7: <code>_obs_f_pick_file</code> &ndash; Datei w&auml;hlen</h2>

        <p><strong>Was sie tut:</strong> Zeigt die 100 neuesten Obsidian-Dateien in einem FZF-Menue.</p>

        <pre><code class="language-bash">_obs_f_pick_file() {
    local vault="$VAULT_AKADEMIE"

    local files_json=$(_obs_eval "$vault" "JSON.stringify(
        app.vault.getFiles()
            .filter(f => f.extension==='md'
                && !f.path.includes('_Archive')
                && !f.path.includes('_templates')
                && !f.path.includes('.obsidian'))
            .sort((a,b) => b.stat.mtime - a.stat.mtime)
            .slice(0,100)
            .map(f => f.path)
    )")

    # JSON-Array -> "pfad|ordner/name" Format fuer FZF
    local file_lines=""
    file_lines=$(echo "$files_json" | python3 -c "
import json, sys, os
vault = '$vault'
for p in json.load(sys.stdin):
    full = os.path.join(vault, p)
    name = os.path.splitext(os.path.basename(p))[0]
    folder = os.path.basename(os.path.dirname(p))
    print(f'{full}|{folder}/{name}')
")

    echo "$file_lines" | fzf --height=30 --reverse --border \
        --border-label=" Datei waehlen (100 neueste) " \
        --prompt="datei > " \
        --delimiter='|' \
        --with-nth=2 | cut -d'|' -f1
}</code></pre>

        <div class="info-box">
            <strong>Trick:</strong> <code>--delimiter='|'</code> und <code>--with-nth=2</code> zeigen nur den schoenen Namen, geben aber den vollen Pfad zurueck.
        </div>


        <!-- ════════════════════════════════════════════════ -->
        <!-- Funktion 8: _obs_f_pick_tag                     -->
        <!-- ════════════════════════════════════════════════ -->
        <h2 id="fn8-pick-tag">Funktion 8: <code>_obs_f_pick_tag</code> &ndash; Tag/Ordner-Filter</h2>

        <pre><code class="language-bash">_obs_f_pick_tag() {
    local vault="$VAULT_AKADEMIE"
    {
        echo "marketing"
        echo "kurse"
        echo "wissen"
        echo "strategie"
        echo "content"
        echo "workflows"
        echo "tools"
        echo "daily"
        echo "--------------"

        local tags_json=$(_obs_eval "$vault" "JSON.stringify(
            Object.entries(app.metadataCache.getTags())
                .sort((a,b) => b[1] - a[1])
                .slice(0,30)
                .map(e => e[0].replace('#',''))
        )")

        if [[ -n "$tags_json" ]]; then
            echo "$tags_json" | python3 -c \
                "import json,sys;[print(t) for t in json.load(sys.stdin)]"
        fi
    } | fzf --height=25 --reverse --border \
        --border-label=" Tag/Ordner Filter " \
        --prompt="filter > "
}</code></pre>


        <!-- ════════════════════════════════════════════════ -->
        <!-- Eigene Patterns                                 -->
        <!-- ════════════════════════════════════════════════ -->
        <h2 id="eigene-patterns">Eigene Patterns hinzuf&uuml;gen</h2>

        <h3>Ins kuratierte Menue</h3>

        <p>Fuege eine Zeile ins <code>CURATED</code>-Array ein:</p>

        <pre><code class="language-bash">"-- MEINE KATEGORIE ----------|"
"mein_custom_pattern         | Meine eigene Analyse"</code></pre>

        <h3>Ein neues Fabric Pattern erstellen</h3>

        <pre><code class="language-bash"># Ordner anlegen
mkdir -p ~/.config/fabric/patterns/mein_custom_pattern

# system.md schreiben
cat > ~/.config/fabric/patterns/mein_custom_pattern/system.md &lt;&lt;'EOF'
# IDENTITY and PURPOSE
Du bist ein Experte fuer [dein Thema].

# STEPS
1. Lies den gesamten Inhalt
2. Identifiziere die 5 wichtigsten Punkte

# OUTPUT FORMAT
- Ausgabe als Markdown
- Deutsche Ueberschriften
- Maximal 500 Woerter
EOF</code></pre>


        <!-- ════════════════════════════════════════════════ -->
        <!-- Globale Variablen                               -->
        <!-- ════════════════════════════════════════════════ -->
        <h2 id="globale-variablen">Globale Variablen</h2>

        <pre><code class="language-bash"># Vault-Pfad
VAULT_AKADEMIE="$HOME/obsidian/Claude/Akademie"

# Fabric Binary (brew-Version, nicht Anaconda)
_OBS_FABRIC_BIN="/opt/homebrew/bin/fabric-ai"

# Fabric Patterns Verzeichnis
_OBS_FABRIC_PATTERNS="$HOME/.config/fabric/patterns"

# Claude-Conversations-Schalter (Session-persistent)
_OBS_F_CLAUDE=0</code></pre>


        <!-- ════════════════════════════════════════════════ -->
        <!-- Minimal-Setup                                   -->
        <!-- ════════════════════════════════════════════════ -->
        <h2 id="minimal-setup">Minimal-Setup zum Nachbauen</h2>

        <h3>1. Datei anlegen</h3>

        <pre><code class="language-bash">touch ~/.zsh/functions/obs-f.zsh</code></pre>

        <h3>2. Minimaler Code</h3>

        <p>Kopiere <code>_obs_f_pick_fabric_pattern</code>, <code>_obs_f_claude_handoff</code> und diese vereinfachte Hauptfunktion:</p>

        <pre><code class="language-bash">obs-f() {
    local vault="$HOME/obsidian/MeinVault"

    local files=()
    while IFS= read -r f; do
        [[ -n "$f" ]] && files+=("$f")
    done < <(find "$vault" -name "*.md" -mtime -1 -type f 2>/dev/null)

    echo "${#files[@]} Dateien gefunden"
    [[ ${#files[@]} -eq 0 ]] && return 1

    local pattern=$(_obs_f_pick_fabric_pattern)
    [[ -z "$pattern" ]] && return 0

    local output
    output=$({
        echo "WICHTIG: Antworte auf Deutsch."
        for f in "${files[@]}"; do
            printf '\n--- %s ---\n' "$(basename "$f" .md)"
            cat "$f"
        done
    } | fabric -p "$pattern")

    echo "$output"
    _obs_f_claude_handoff "$output" "$pattern" "${#files[@]}"
}</code></pre>

        <h3>3. Laden</h3>

        <pre><code class="language-bash">echo 'source ~/.zsh/functions/obs-f.zsh' >> ~/.zshrc
source ~/.zshrc
obs-f</code></pre>


        <!-- ════════════════════════════════════════════════ -->
        <!-- Datei-Uebersicht                                -->
        <!-- ════════════════════════════════════════════════ -->
        <h2 id="datei-uebersicht">Datei-&Uuml;bersicht</h2>

        <table>
            <thead><tr><th>Datei</th><th>Zweck</th></tr></thead>
            <tbody>
                <tr><td><code>~/.zsh/functions/obsidian-vaults.zsh</code></td><td>Alle 8 Funktionen (Quelldatei)</td></tr>
                <tr><td><code>~/.config/fabric/patterns/*/system.md</code></td><td>239 Fabric Pattern-Definitionen</td></tr>
                <tr><td><code>~/.state/obs-f-context.md</code></td><td>Temporaere Kontext-Datei fuer Claude Code</td></tr>
                <tr><td><code>~/.zshrc</code></td><td>Hier wird die Funktionsdatei geladen</td></tr>
            </tbody>
        </table>

    </main>

</div>

<!-- ═══════════════════════════════════════════════════════ -->
<!-- FOOTER                                                 -->
<!-- ═══════════════════════════════════════════════════════ -->
<footer class="page-footer">
    <div class="footer-inner">
        <div class="footer-brand">
            <img src="https://raw.githubusercontent.com/HolgerGelhausen/ai-performance-academy-assets/main/logo-cropped.png" alt="AIPA Logo">
            <span>AI Performance Academy</span>
        </div>
        <div class="footer-meta">
            obs-f v5.8.0 &mdash; 18.02.2026 &mdash; Version 4.2.0
        </div>
        <a href="https://ai-pa.ai/vortraege/">&larr; Alle Vortr&auml;ge</a>
    </div>
</footer>

<!-- ═══════════════════════════════════════════════════════ -->
<!-- SCRIPTS                                                -->
<!-- ═══════════════════════════════════════════════════════ -->

<!-- Prism.js Core + Bash + Markdown -->
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-bash.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-markdown.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-javascript.min.js"></script>

<!-- Mermaid.js -->
<script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
<script>
    mermaid.initialize({
        startOnLoad: true,
        theme: 'base',
        themeVariables: {
            primaryColor: '#F7F8FA',
            primaryTextColor: '#1F1F1F',
            primaryBorderColor: '#D9DDE3',
            lineColor: '#767D8C',
            secondaryColor: '#FFFFFF',
            tertiaryColor: '#F7F8FA',
            fontFamily: 'Montserrat, sans-serif'
        }
    });
</script>

<!-- Mobile TOC Toggle + Scroll Spy -->
<script>
    document.addEventListener('DOMContentLoaded', function() {
        var tocToggle = document.getElementById('tocToggle');
        var toc = document.getElementById('toc');

        if (tocToggle && toc) {
            tocToggle.addEventListener('click', function() {
                toc.classList.toggle('mobile-open');
                tocToggle.textContent = toc.classList.contains('mobile-open') ? '\u2715' : '\u2630';
            });

            // Close TOC when a link is clicked (mobile)
            var tocLinks = toc.querySelectorAll('a');
            tocLinks.forEach(function(link) {
                link.addEventListener('click', function() {
                    if (window.innerWidth <= 900) {
                        toc.classList.remove('mobile-open');
                        tocToggle.textContent = '\u2630';
                    }
                });
            });
        }

        // Active TOC link on scroll
        var sections = document.querySelectorAll('h2[id]');
        var navLinks = document.querySelectorAll('.toc a');

        function updateActiveTocLink() {
            var scrollPos = window.scrollY + 120;
            var currentSection = '';

            sections.forEach(function(section) {
                if (section.offsetTop <= scrollPos) {
                    currentSection = section.getAttribute('id');
                }
            });

            navLinks.forEach(function(link) {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + currentSection) {
                    link.classList.add('active');
                }
            });
        }

        window.addEventListener('scroll', updateActiveTocLink);
        updateActiveTocLink();
    });
</script>

</body>
</html>
